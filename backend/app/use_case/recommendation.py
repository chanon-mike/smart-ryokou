import logging
from typing import List
from app.schema.recommendation import (
    PromptRecommendationResponse,
    PromptRecommendationsQuery,
    RecommendationResponse,
    StructuredQuery,
)
import json5
from openai import OpenAI
from openai.resources.chat.completions import ChatCompletion, ChatCompletionMessageParam
from openai.types.chat.completion_create_params import Function
from app.core.config import settings

logger = logging.getLogger(__name__)


class RecommendationUseCase:
    def __init__(self):
        openai_api_key = settings.OPENAI_API_KEY
        base_url = "https://api.openai.iniad.org/api/v1"

        self.client = OpenAI(
            api_key=openai_api_key,
            base_url=base_url,
        )

    def _extract_json(self, response: str):
        """Extract json from openai response."""
        # Sometimes json generated by openai have trailing comma -> invalid to parse to JSON -> need to use json5 which has more relaxed syntax than json
        # Ref: https://stackoverflow.com/questions/23705304/can-json-loads-ignore-trailing-commas
        try:
            return json5.loads(response)
        except Exception as e:
            logger.error(f"Error decoding JSON: {e}")
            raise ValueError("Invalid JSON format") from e

    def chat_completion_request(
        self,
        model: str = "gpt-3.5-turbo",
        messages: List[ChatCompletionMessageParam] = None,
        functions: List[Function] = None,
    ) -> ChatCompletion:
        """Send request to OpenAI chat completion API."""
        try:
            response = self.client.chat.completions.create(
                model=model, messages=messages, functions=functions
            )
            return response
        except Exception as e:
            logger.error(f"ChatCompletion Error: {e}")
            raise Exception(f"ChatCompletion Error: {e}")

    def parse_response(self, response: ChatCompletion):
        """Parse response from OpenAI chat completion API."""
        function_call = response.choices[0].message.function_call

        if function_call:
            response_json = self._extract_json(function_call.arguments)
            logger.info(f"Response: {response_json}")
            return response_json
        else:
            logger.error(f"Error: {response}")
            raise ValueError("Invalid response from OpenAI")


class StructuredRecommendationUseCase(RecommendationUseCase):
    def __init__(self):
        super().__init__()
        self.functions: List[Function] = [
            {
                "name": "send_itinerary",
                "description": "Create itinerary plan based on user input.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "title": {
                            "type": "string",
                            "description": "Title for recommended itinerary in Japanese.",
                        },
                        "recommendation": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "date": {
                                        "type": "string",
                                        "description": "Date in recommended itinerary, e.g 9月1日.",
                                    },
                                    "activities": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "place": {
                                                    "type": "string",
                                                    "description": "Recommended place in Japanese.",
                                                },
                                                "description": {
                                                    "type": "string",
                                                    "description": "Description of a recommended place in Japanese.",
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    "required": ["title", "recommendation"],
                },
            }
        ]

    def _build_prompt(self, query: StructuredQuery) -> str:
        prompt = (
            "Create itinerary Include a mix of well-known and hidden gems. Each recommendation should be geographically feasible,"
            "include what makes the place special and activities that align with the user's interests. The itinerary should be realistically possible,"
            "considering travel times between locations. Base on the following information:\n"
            f"Place: {query.place}\n"
            f"Date: {query.date_from} to {query.date_to}\n"
            f"People number: {query.people_num}\n"
        )

        optional_fields = {
            "budget": query.budget,
            "trip_pace": query.trip_pace,
            "interests": ", ".join(query.interests) if query.interests else None,
            "trip_type": query.trip_type,
        }
        for field_name, value in optional_fields.items():
            if value:
                prompt += f"{field_name}: {value}\n"

        return prompt

    def get_recommendations(self, query: StructuredQuery) -> RecommendationResponse:
        prompt = self._build_prompt(query)
        response = self.chat_completion_request(
            messages=[
                {
                    "role": "system",
                    "content": "You are a Japanese travel planner. You suggest plan in Japanese.",
                },
                {
                    "role": "system",
                    "content": f"Ask for clarification if there is no existing location named '{query.place}'.",
                },
                {"role": "user", "content": prompt},
                {"role": "user", "content": "Send generated trip to user"},
            ],
            functions=self.functions,
        )
        response_json: RecommendationResponse = self.parse_response(response)

        return response_json


class PromptRecommendationUseCase(RecommendationUseCase):
    def __init__(self):
        super().__init__()
        self.functions: List[Function] = [
            {
                "name": "send_recommendations",
                "description": "Send additional recommendations to user in Japanese.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "recommendations": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "place": {
                                        "type": "string",
                                        "description": "Recommended place in Japanese.",
                                    },
                                    "description": {
                                        "type": "string",
                                        "description": "Description of a recommended place in Japanese.",
                                    },
                                },
                            },
                        }
                    },
                },
            }
        ]

    def _build_prompt(self, query: PromptRecommendationsQuery) -> str:
        prompt = (
            f"Suggest places in above area which match the following requirement: '{query.user_prompt}'.",
            f"Suggested places must not include {', '.join(query.suggested_places)}.",
        )
        return prompt

    def get_recommendations(
        self, query: PromptRecommendationsQuery
    ) -> PromptRecommendationResponse:
        prompt = self._build_prompt(query)
        response = self.chat_completion_request(
            messages=[
                {
                    "role": "system",
                    "content": "You are a travel planner. You suggest plan in Japanese.",
                },
                {
                    "role": "user",
                    "content": f"Return the name of place in this trip title: {query.trip_title}",
                },
                {"role": "user", "content": prompt},
                {"role": "user", "content": "Send recommended places to user"},
            ],
            functions=self.functions,
        )
        response_json: PromptRecommendationResponse = self.parse_response(response)

        return response_json
